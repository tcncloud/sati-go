---
globs: pkg/domain/*.go,pkg/ports/*.go,pkg/sati/**/*.go
description: Clean architecture patterns and dependency inversion principles
---

# Clean Architecture Patterns

## Layer Structure

### Ports Layer (Interfaces)
- **Location**: `pkg/ports/`
- **Purpose**: Define interfaces that the application depends on
- **Pattern**: Pure interfaces with no implementation details
- **Naming**: Use descriptive interface names (e.g., `ConfigWatcher`, `ConfigLoader`)

```go
// Ports define what the application needs
type ConfigWatcher interface {
    Start(ctx context.Context) error
    Stop() error
    IsWatching() bool
}
```

### Domain Layer (Business Logic)
- **Location**: `pkg/domain/`
- **Purpose**: Contains business logic and domain entities
- **Pattern**: Depends only on ports, not on adapters
- **Dependencies**: Only import `pkg/ports/` and standard library

```go
// Domain depends on ports, not implementations
type Domain struct {
    configWatcher ports.ConfigWatcher
}

func (d *Domain) StartConfigWatcher(ctx context.Context) error {
    return d.configWatcher.Start(ctx)
}
```

### Adapters Layer (Infrastructure)
- **Location**: `pkg/sati/`
- **Purpose**: Implements ports interfaces with concrete implementations
- **Pattern**: Implements ports interfaces, handles external concerns
- **Dependencies**: Can import domain, ports, and external libraries

```go
// Adapters implement ports interfaces
type ConfigWatcher struct {
    // implementation details
}

func (cw *ConfigWatcher) Start(ctx context.Context) error {
    // concrete implementation
}
```

## Dependency Direction

### Dependency Flow
```
Domain → Ports ← Adapters
```

- **Domain** depends on **Ports** (interfaces)
- **Adapters** implement **Ports** (interfaces)
- **Domain** never depends on **Adapters**
- **Adapters** can depend on **Domain** for business logic

### Interface Segregation
- Keep interfaces small and focused
- Each interface should have a single responsibility
- Avoid "god interfaces" with many methods
- Group related functionality into separate interfaces

## Module Organization

### Ports Module Structure
```go
// pkg/ports/interface.go - Client interface
package ports

type ClientInterface interface {
    Close() error
    AddAgentCallResponse(ctx context.Context, params AddAgentCallResponseParams) (AddAgentCallResponseResult, error)
    GetAgentByID(ctx context.Context, params GetAgentByIDParams) (GetAgentByIDResult, error)
    // ... other client methods
}

// pkg/ports/config.go - Configuration interfaces
package ports

type ConfigWatcher interface {
    Start(ctx context.Context) error
    Stop() error
    IsWatching() bool
}

type ConfigLoader interface {
    LoadConfig(path string) (interface{}, error)
    LoadConfigFromString(configString string) (interface{}, error)
}

// pkg/ports/types.go - All custom types and parameters
package ports

type AddAgentCallResponseParams struct {
    PartnerAgentID string
    CallSid        int64
    ResponseKey    string
    ResponseValue  string
    AgentSid       int64
}

type AddAgentCallResponseResult struct{}
```

### Domain Module Structure
```go
// pkg/domain/domain.go
package domain

import "github.com/tcncloud/sati-go/pkg/ports"

type Domain struct {
    configWatcher ports.ConfigWatcher
}

func NewDomain() *Domain {
    return &Domain{}
}

func (d *Domain) SetConfigWatcher(watcher ports.ConfigWatcher) {
    d.configWatcher = watcher
}
```

### Adapter Module Structure
```go
// pkg/sati/client/client.go - Client implementation
package client

import "github.com/tcncloud/sati-go/pkg/ports"

type Client struct {
    conn *grpc.ClientConn
    gate gatev2pb.GateServiceClient
}

// Ensure interface compliance
var _ ports.ClientInterface = (*Client)(nil)

func NewClient(cfg *saticonfig.Config) (*Client, error) {
    // implementation
}

func (c *Client) AddAgentCallResponse(ctx context.Context, params ports.AddAgentCallResponseParams) (ports.AddAgentCallResponseResult, error) {
    // implementation
}

// pkg/sati/config/config.go - Config implementation
package config

import "github.com/tcncloud/sati-go/pkg/ports"

type ConfigWatcher struct {
    // implementation details
}

func (cw *ConfigWatcher) Start(ctx context.Context) error {
    // implementation
}

// Ensure interface compliance
var _ ports.ConfigWatcher = (*ConfigWatcher)(nil)
```

## Dependency Injection Patterns

### Constructor Injection
```go
// Preferred: Constructor injection
func NewDomain(configWatcher ports.ConfigWatcher) *Domain {
    return &Domain{
        configWatcher: configWatcher,
    }
}
```

### Setter Injection
```go
// Alternative: Setter injection for optional dependencies
func (d *Domain) SetConfigWatcher(watcher ports.ConfigWatcher) {
    d.configWatcher = watcher
}
```

### Interface Segregation
```go
// Good: Small, focused interfaces
type ConfigWatcher interface {
    Start(ctx context.Context) error
    Stop() error
}

type ConfigLoader interface {
    LoadConfig(path string) (interface{}, error)
}

// Avoid: Large interfaces with many responsibilities
type ConfigManager interface {
    Start(ctx context.Context) error
    Stop() error
    LoadConfig(path string) (interface{}, error)
    SaveConfig(config interface{}) error
    ValidateConfig(config interface{}) error
}
```

## Testing Patterns
- Test domain with mock implementations
- Test adapters with real implementations
- Use interface mocks for testing
- Test integration points separately
- See [testing-guidelines.mdc](mdc:.cursor/rules/testing-guidelines.mdc) for comprehensive testing patterns

## Error Handling
- Domain should return domain-specific errors
- Adapters should wrap external errors with domain context
- Use error wrapping to maintain error chain
- See [go-best-practices.mdc](mdc:.cursor/rules/go-best-practices.mdc) for detailed error handling patterns

## Current Project Structure

### Ports Package (`pkg/ports/`)
- **`interface.go`**: Contains `ClientInterface` with all client method signatures
- **`types.go`**: Contains all custom parameter and result types (`XxxParams`, `XxxResult`)
- **`config.go`**: Contains `ConfigWatcher` and `ConfigLoader` interfaces
- **`doc.go`**: Package documentation

### Adapters Package (`pkg/sati/`)
- **`client/`**: gRPC client implementation
  - **`client.go`**: Concrete `Client` struct implementing `ports.ClientInterface`
  - **`client_test.go`**: Unit tests for client methods
- **`config/`**: Configuration management implementation
  - **`config.go`**: Concrete implementations of config interfaces
  - **`module.go`**: FX module definitions

### Command Package (`pkg/cmd/`)
- All CLI commands use `saticlient.NewClient(cfg)` to create clients
- All commands use `ports.XxxParams` and `ports.XxxResult` for types
- Commands depend on `ports.ClientInterface` for abstraction

## Best Practices

### Layer Responsibilities
- **Ports**: Define contracts, no implementation
- **Domain**: Business logic, depends only on ports
- **Adapters**: External concerns, implements ports

### Interface Design
- Keep interfaces small and focused
- Use descriptive names
- Avoid leaking implementation details
- Group related functionality

### Dependency Management
- Use constructor injection when possible
- Avoid circular dependencies
- Keep domain pure (no external dependencies)
- Use interfaces for all external dependencies

### Type Organization
- All custom types go in `pkg/ports/types.go`
- Use `XxxParams` for method parameters
- Use `XxxResult` for method return values
- Keep types focused and single-purpose

### Client Implementation
- Concrete client in `pkg/sati/client/`
- Interface defined in `pkg/ports/interface.go`
- All methods use ports types for parameters and results
- Ensure interface compliance with `var _ ports.ClientInterface = (*Client)(nil)`

### Testing Strategy
- Test domain with mocks
- Test adapters with real implementations
- Use interface mocks for testing
- Test integration points separately